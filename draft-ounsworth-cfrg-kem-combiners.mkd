---
title: Combiner function for hybrid key encapsulation mechanisms (Hybrid KEMs)
abbrev: KEM Combiner
# <!-- EDNOTE: Edits the draft name -->
docname: draft-ounsworth-cfrg-kem-combiners-00

# <!-- stand_alone: true -->
ipr: trust200902
area: Security
stream: IRTF
wg: CFRG
kw: Internet-Draft
cat: info
venue:
  group: "Limited Additional Mechanisms for PKIX and SMIME (lamps)"
  type: "Working Group"
  mail: "spasm@ietf.org"
  arch: "https://mailarchive.ietf.org/arch/browse/spasm/"
  repo: "https://github.com/EntrustCorporation/draft-ounsworth-cfrg-kem-combiners"

coding: utf-8
pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:
    -
      ins: M. Ounsworth
      name: Mike Ounsworth
      org: Entrust Limited
      abbrev: Entrust
      street: 2500 Solandt Road – Suite 100
      city: Ottawa, Ontario
      country: Canada
      code: K2K 3G5
      email: mike.ounsworth@entrust.com
    -
      ins: A. Wussler
      name: Aron Wussler
      org: Proton AG
      abbrev: Proton
      country: Switzerland
      email: aron@wussler.it


normative:
  RFC2119:

# <!-- EDNOTE: full syntax for this defined here: https://github.com/cabo/kramdown-rfc2629 -->

informative:
  RFC8174:
  RFC8411:
  RFC8784:
  RFC8696:
  RFC8784:
  I-D.ietf-lamps-cmp-updates:
  I-D.driscoll-pqt-hybrid-terminology:
  I-D.ietf-tls-hybrid-design:
  I-D.ietf-ipsecme-ikev2-multiple-ke:
  I-D.ounsworth-pq-composite-kem:
  I-D.wussler-openpgp-pqc:
  PQCAPI:
    title: "PQC - API notes"
    target: https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/example-files/api-notes.pdf
    author:
      - name: NIST Post-Quantum Cryptography Project
    date: November 2022
  SP800-56A:
    target: https://doi.org/10.6028/NIST.SP.800-56Ar3
    title: Recommendation for Pair-Wise Key-Establishment Schemes Using Discrete Logarithm Cryptography
    author:
      -
        ins: E. Barker
        name: Elaine Barker
      -
        ins: L. Chen
        name: Lily Chen
      -
        ins: A. Roginsky
        name: Allen Roginsky
      -
        ins: A. Vassilev
        name: Apostol Vassilev
      -
        ins: R. Davis
        name: Richard Davis
    date: April 2018
    seriesinfo:
      NIST Special Publication 800-56A
  SP800-56C:
    target: https://doi.org/10.6028/NIST.SP.800-56Cr2
    title: Recommendation for Key-Derivation Methods in Key-Establishment Schemes
    author:
      -
        ins: E. Barker
        name: Elaine Barker
      -
        ins: L. Chen
        name: Lily Chen
      -
        ins: R. Davis
        name: Richard Davis
    date: August 2020
    seriesinfo:
      NIST Special Publication 800-56C
  SPONGE:
    target: https://keccak.team/files/CSF-0.1.pdf
    title: Cryptographic sponge functions
    author:
      -
        ins: G. Bertoni
        name: Guido Bertoni
      -
        ins: J. Daemen
        name: Joan Daemen
      -
        ins: M. Peters
        name: Michael Peters
      -
        ins: G. Assche
        name: Gilles van Assche
    date: January 2011




--- abstract

The migration to post-quantum cryptography often calls for performing multiple key encapsulations in parallel and then combining their outputs to derive a single shared secret.

This document defines a flexible multi-share KEM combiner, that fulfils the security criteria to join an arbitrary number of key shares.

<!-- End of Abstract -->

--- middle


# Terminology {#sec-terminology}
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 {{RFC2119}}  {{RFC8174}} when, and only when, they appear in all capitals, as shown here.

This document is consistent with all terminology defined in {{I-D.driscoll-pqt-hybrid-terminology}}.

## Key Encapsulation Mechanisms {#sec-kem-defn}

For the purposes of this document, we consider a Key Encapsulation Mechanism (KEM) to be any asymmetric cryptographic scheme comprised of algorithms satisfying the following interfaces [PQCAPI].

~~~
def kemKeyGen() -> (pk, sk)
def kemEncaps(pk) -> (ct, ss)
def kemDecaps(ct, sk) -> ss
~~~

where `pk` is public key, `sk` is secret key, `ct` is ciphertext, and `ss` is shared secret.

KEMs are typically used in cases where two parties, hereby refereed to as the "encapsulater" and the "decapsulater", wish to establish a shared secret via public key cryptography, where the decapsulater has an asymmetric key pair and has previously shared the public key with the encapsulater.


# Introduction {#sec-intro}

The need for a KEM combiner function arises in three different contexts within IETF security protocols:

1. KEM / PSK hybrids where the output of a KEM is combined with a static pre-shared key.
1. Post-quantum / traditional hybrid KEMs.
1. KEM-based authenticated key exchanges (AKEs).

This document normalizes a mechanisms for combining the output of two KEMs.

## KEM/PSK hybrids

As a post-quantum stop-gap, several IETF protocols have added extensions to allow for mixing a pre-shared key (PSK) into an (EC)DH based key exchange. Examples include CMS [RFC8696] and IKEv2 [RFC8784].

## PQ/Traditional hybrid KEMs

A post-quantum / traditional hybrid key encapsulation mechanism (hybrid KEM) as defined in {{I-D.driscoll-pqt-hybrid-terminology}} as

 PQ/T Hybrid Key Encapsulation Mechanism:

: A Key Encapsulation Mechanism (KEM) made up of two or more component KEM algorithms where at least one is a post-quantum algorithm and at least one is a traditional algorithm.

Building a PQ/T hybrid KEM requires a secure function which combines the output of both component KEMs to form a single output. Several IETF protocols are adding PQ/T hybrid KEM mechanisms as part of their overall post-quantum migration strategies, examples include TLS 1.3 [I-D.ietf-tls-hybrid-design], IKEv2 [I-D.ietf-ipsecme-ikev2-multiple-ke], X.509; PKIX; CMS [I-D.ounsworth-pq-composite-kem], OpenPGP [I-D.wussler-openpgp-pqc], JOSE / COSE (CITE once Orie's drafts are up).

## KEM-based AKE

The need for a KEM-based authenticated key establishment arises, for example, when two communicating parties each have long-term KEM keys (for example in X.509 certificates), and wish to involve both KEM keys in deriving a mutually-authenticated shared secret. In particular this will arise for any protocol that needs to provide post-quantum replacements for static-static (elliptic curve) Diffie-Hellman mechanisms. Examples include a KEM replacement for CMP's DHBasedMac {{I-D.ietf-lamps-cmp-updates}}, .. TODO: cite others.


# KEM Combiner construction {#sec-kemcombiner}

<!--
TODO: read and cite the ETSI doc "Quantum-safe Hybrid Key Exchanges"
https://www.etsi.org/deliver/etsi_ts/103700_103799/103744/01.01.01_60/ts_103744v010101p.pdf

TODO: as per https://www.enisa.europa.eu/publications/post-quantum-cryptography-integration-study section 4.2, might need to specify behaviour in light of KEMs with a non-zero failure probability.

TODO: read and cite
Federico Giacon, Felix Heuer, and Bertram Poettering. KEM combiners. In Michel
Abdalla and Ricardo Dahab, editors, PKC 2018: 21st International Conference on Theory
and Practice of Public Key Cryptography, Part I, volume 10769 of Lecture Notes in Computer Science, pages 190–218. Springer, Heidelberg, March 2018.
-->


A KEM combiner is a function that takes in two or more shared secrets and returns a combined shared secret, where all values are byte arrays.

~~~
SS = kemCombiner(SS_1, SS_2, ..., SS_n)
~~~

This document assumes that shared secrets are the output of a KEM, but without loss of generality they may also be any other source of cryptographic key material, such as pre-shared keys (PSKs), with PQ/PSK being a quantum-safe migration strategy being made available by some protocols, see for example IKEv2 in [RFC8784].

In general it is desirable to use a multi-PRF as a KEM combiner, a function that can be keyed by any input.
The following simple yet generic construction can be used in all IETF protocols that need to combine the output of two or more KEMs:

~~~
KDF(counter || K_1 || ... || K_n || fixedInfo)
~~~
{: title="general KEM combiner construction" }

where `KDF` represents a suitable choice of cryptographic key derivation function, `K_i` represent the constant-length input keys, `fixedInfo` is some protocol-specific KDF binding, and `||` represents concatenation.
The counter parameter is instantiation specific.

This construction is in line with NIST SP-800 56Cr2 {{SP800-56C}}.
In section {{sec-instantiation}} several possible practical instantiations will be proposed.

Each `K_i` MUST be constant in length, therefore the secret shares `SS_i` can be used directly only if they are guaranteed to be constant length. For all other cases, it is REQUIRED to hash them first:

~~~
K_i = H(SS_i)
~~~

## Protocol binding
The `fixedInfo` string is a fixed-length string containing some context-specific information.
It MUST NOT depend on the secret shares.

A non-comprehensive list of information that can be included in the fixedInfo can be found in paragraph 5.8.2 of NIST SP800-56Ar3 {{SP800-56A}}.

The `fixedInfo` string MUST have a definite structure depending on the protocol where all parts are fixed length. This prevents possible cases where a variable length structure could be used to create collisions between two different instances.
In cases some variable length input is necessary, such as the representation of a public key or an OID, then hashing or padding can be used.

## Practical instantiations {#sec-instantiation}

The KDF MUST be instantiated with one of the following Keccak-based option.
Each instance defines a function to be used as KDF, a hash function to optionally derive the `K_i`, and a counter.

1. `KDF = SHA3-256` and `H = SHA3-256`. The counter MUST be initialized with the string `0x00000001` and MUST be increased by 0x01 if more key material is needed.
2. `KDF = SHA3-512` and `H = SHA3-512`. The counter MUST be initialized with the string `0x00000001` and MUST be increased by 0x01 if more key material is needed.
3. `KDF = KMAC128` and `H = SHA3-256`. The counter MUST be the fixed string `0x00000001`.
4. `KDF = KMAC256` and `H = SHA3-512`. The counter MUST be the fixed string `0x00000001`.

# IANA Considerations {#sec-iana}

None.

# Security Considerations

The proposed instantiations in {{sec-instantiation}} are practical multi-PRFs and this specification limits to the use of Keccak-based constructions. The sponge construction was proven to be indifferentiable from a random oracle {{SPONGE}}.
More precisely, for a given capacity `c` the indifferentiability proof shows that assuming there are no weaknesses found in the Keccak permutation, an attacker has to make an expected number of `2^(c/2)` calls to the permutation to tell Keccak from a random oracle.
For a random oracle, a difference in only a single bit gives an unrelated, uniformly random output.
Hence, to be able to distinguish a key `K`, derived from shared keys `K_i` from a random bit string, an adversary has to correctly guess all key shares `K_i` entirely.

<!-- Start of Appendices -->
--- back

# Acknowledgements
{:numbered="false"}

This document incorporates contributions and comments from a large group of experts. The Editors would especially like to acknowledge the expertise and tireless dedication of the following people, who attended many long meetings and generated millions of bytes of electronic mail and VOIP traffic over the past years in pursuit of this document:

Douglas Stebila, Nimrod Aviram, Andreas Huelsing, and Stavros Kousidis.

We are grateful to all, including any contributors who may have
been inadvertently omitted from this list.

This document borrows text from similar documents, including those referenced below. Thanks go to the authors of those
   documents.  "Copying always makes things easier and less error prone" - [RFC8411].

<!-- End of Contributors section -->
