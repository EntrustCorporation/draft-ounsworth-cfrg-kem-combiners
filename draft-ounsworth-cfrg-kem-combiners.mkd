---
title: Combiner function for hybrid key encapsulation mechanisms (Hybrid KEMs)
abbrev: KEM Combiner
# <!-- EDNOTE: Edits the draft name -->
docname: draft-ounsworth-cfrg-kem-combiners-00

# <!-- stand_alone: true -->
ipr: trust200902
area: Security
stream: IRTF
wg: CFRG
kw: Internet-Draft
cat: info
venue:
  group: "Limited Additional Mechanisms for PKIX and SMIME (lamps)"
  type: "Working Group"
  mail: "spasm@ietf.org"
  arch: "https://mailarchive.ietf.org/arch/browse/spasm/"
  repo: "https://github.com/EntrustCorporation/draft-ounsworth-cfrg-kem-combiners"

coding: utf-8
pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:
    -
      ins: M. Ounsworth
      name: Mike Ounsworth
      org: Entrust Limited
      abbrev: Entrust
      street: 2500 Solandt Road – Suite 100
      city: Ottawa, Ontario
      country: Canada
      code: K2K 3G5
      email: mike.ounsworth@entrust.com
    -
      ins: A. Wussler
      name: Aron Wussler
      org: Proton AG
      abbrev: Proton
      country: Switzerland
      email: aron@wussler.it


normative:
  RFC2119:

# <!-- EDNOTE: full syntax for this defined here: https://github.com/cabo/kramdown-rfc2629 -->

informative:
  RFC8174:
  RFC8411:
  RFC8784:
  RFC8696:
  RFC8784:
  I-D.ietf-lamps-cmp-updates:
  I-D.driscoll-pqt-hybrid-terminology:
  I-D.ietf-tls-hybrid-design:
  I-D.ietf-ipsecme-ikev2-multiple-ke:
  I-D.ounsworth-pq-composite-kem:
  I-D.wussler-openpgp-pqc:
  PQCAPI:
    title: "PQC - API notes"
    target: https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/example-files/api-notes.pdf
    author:
      - name: NIST Post-Quantum Cryptography Project
    date: November 2022
  SP800-56A:
    target: https://doi.org/10.6028/NIST.SP.800-56Ar3
    title: Recommendation for Pair-Wise Key-Establishment Schemes Using Discrete Logarithm Cryptography
    author:
      -
        ins: E. Barker
        name: Elaine Barker
      -
        ins: L. Chen
        name: Lily Chen
      -
        ins: A. Roginsky
        name: Allen Roginsky
      -
        ins: A. Vassilev
        name: Apostol Vassilev
      -
        ins: R. Davis
        name: Richard Davis
    date: April 2018
    seriesinfo:
      NIST Special Publication 800-56A
  SP800-56C:
    target: https://doi.org/10.6028/NIST.SP.800-56Cr2
    title: Recommendation for Key-Derivation Methods in Key-Establishment Schemes
    author:
      -
        ins: E. Barker
        name: Elaine Barker
      -
        ins: L. Chen
        name: Lily Chen
      -
        ins: R. Davis
        name: Richard Davis
    date: August 2020
    seriesinfo:
      NIST Special Publication 800-56C
  SP800-185:
    target: https://doi.org/10.6028/NIST.SP.800-185
    title: "SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash, and ParallelHash"
    author:
      -
        ins: J. Kelsey
        name: John Kelsey
      -
        ins: S. Chan
        name: Shu-jen Chan
      -
        ins: R. Perln
        name: Ray Perln
    date: 2016
    seriesinfo:
      NIST Special Publication 800-185
  FIPS202:
    target: https://doi.org/10.6028/NIST.FIPS.202
    title: "SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions"
    date: 2015
    seriesinfo:
      Federal information Processing Standards Publication (FIPS) 202
  SPONGE:
    target: https://keccak.team/files/CSF-0.1.pdf
    title: Cryptographic sponge functions
    author:
      -
        ins: G. Bertoni
        name: Guido Bertoni
      -
        ins: J. Daemen
        name: Joan Daemen
      -
        ins: M. Peters
        name: Michael Peters
      -
        ins: G. Assche
        name: Gilles van Assche
    date: January 2011

--- abstract

The migration to post-quantum cryptography often calls for performing multiple key encapsulations in parallel and then combining their outputs to derive a single shared secret.

This document defines a flexible multi-share KEM combiner to join an arbitrary number of key shares, that is a multi-PRF compatible with NIST SP 800-56Cr2 [SP800-56C].

<!-- End of Abstract -->

--- middle


# Terminology {#sec-terminology}
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 {{RFC2119}}  {{RFC8174}} when, and only when, they appear in all capitals, as shown here.

This document is consistent with all terminology defined in {{I-D.driscoll-pqt-hybrid-terminology}}.

## Key Encapsulation Mechanisms {#sec-kem-defn}

For the purposes of this document, we consider a Key Encapsulation Mechanism (KEM) to be any asymmetric cryptographic scheme comprised of algorithms satisfying the following interfaces [PQCAPI].

~~~
def kemKeyGen() -> (pk, sk)
def kemEncaps(pk) -> (ct, ss)
def kemDecaps(ct, sk) -> ss
~~~

where `pk` is public key, `sk` is secret key, `ct` is the ciphertext representing an encapsulated key, and `ss` is shared secret.

KEMs are typically used in cases where two parties, hereby refereed to as the "encapsulater" and the "decapsulater", wish to establish a shared secret via public key cryptography, where the decapsulater has an asymmetric key pair and has previously shared the public key with the encapsulater.


# Introduction {#sec-intro}

The need for a KEM combiner function arises in three different contexts within IETF security protocols:

1. KEM / PSK hybrids where the output of a KEM is combined with a static pre-shared key.
1. Post-quantum / traditional hybrid KEMs where output of a post-quantum KEM is combined with the output of a classical key transport or key exchange algorithm.
1. KEM-based authenticated key exchanges (AKEs) where the output of two or more KEMs performed in different directions are combined.

This document normalizes a mechanisms for combining the output of two or more KEMs.

## KEM/PSK hybrids

As a post-quantum stop-gap, several IETF protocols have added extensions to allow for mixing a pre-shared key (PSK) into an (EC)DH based key exchange. Examples include CMS [RFC8696] and IKEv2 [RFC8784].

## PQ/Traditional hybrid KEMs

A post-quantum / traditional hybrid key encapsulation mechanism (hybrid KEM) as defined in {{I-D.driscoll-pqt-hybrid-terminology}} as

 PQ/T Hybrid Key Encapsulation Mechanism:

: A Key Encapsulation Mechanism (KEM) made up of two or more component KEM algorithms where at least one is a post-quantum algorithm and at least one is a traditional algorithm.

Building a PQ/T hybrid KEM requires a secure function which combines the output of both component KEMs to form a single output. Several IETF protocols are adding PQ/T hybrid KEM mechanisms as part of their overall post-quantum migration strategies, examples include TLS 1.3 [I-D.ietf-tls-hybrid-design], IKEv2 [I-D.ietf-ipsecme-ikev2-multiple-ke], X.509; PKIX; CMS [I-D.ounsworth-pq-composite-kem], OpenPGP [I-D.wussler-openpgp-pqc], JOSE / COSE (CITE once Orie's drafts are up).

## KEM-based AKE

The need for a KEM-based authenticated key establishment arises, for example, when two communicating parties each have long-term KEM keys (for example in X.509 certificates), and wish to involve both KEM keys in deriving a mutually-authenticated shared secret. In particular this will arise for any protocol that needs to provide post-quantum replacements for static-static (Elliptic Curve) Diffie-Hellman mechanisms. Examples include a KEM replacement for CMP's DHBasedMac {{I-D.ietf-lamps-cmp-updates}}.


# KEM Combiner construction {#sec-kem-combiner}

<!--
TODO: read and cite the ETSI doc "Quantum-safe Hybrid Key Exchanges"
https://www.etsi.org/deliver/etsi_ts/103700_103799/103744/01.01.01_60/ts_103744v010101p.pdf

TODO: as per https://www.enisa.europa.eu/publications/post-quantum-cryptography-integration-study section 4.2, might need to specify behaviour in light of KEMs with a non-zero failure probability.

TODO: read and cite
Federico Giacon, Felix Heuer, and Bertram Poettering. KEM combiners. In Michel
Abdalla and Ricardo Dahab, editors, PKC 2018: 21st International Conference on Theory
and Practice of Public Key Cryptography, Part I, volume 10769 of Lecture Notes in Computer Science, pages 190–218. Springer, Heidelberg, March 2018.
-->


A KEM combiner is a function that takes in two or more shared secrets `ss_i` and returns a combined shared secret `ss`, where all values are byte arrays.

~~~
ss = kemCombiner(ss_1, ss_2, ..., ss_n)
~~~

This document assumes that shared secrets are the output of a KEM, but without loss of generality they MAY also be any other source of cryptographic key material, such as pre-shared keys (PSKs), with PQ/PSK being a quantum-safe migration strategy being made available by some protocols, see for example IKEv2 in [RFC8784].

In general it is desirable to use a multi-PRF as a KEM combiner, a function that can be keyed by any input.
The following simple yet generic construction can be used in all IETF protocols that need to combine the output of two or more KEMs:

~~~
KDF(counter || k_1 || ... || k_n || fixedInfo, outputBits)
~~~
{: title="general KEM combiner construction" }

where:

- `KDF` represents a suitable choice of cryptographic key derivation function,
- `k_i` represent the constant-length input keys,
- `fixedInfo` is some protocol-specific KDF binding,
- `counter` parameter is instantiation-specific and is discussed in {{sec-instantiation}}.
- `outputBits` determines the length of the key,
- `||` represents concatenation.

In section {{sec-instantiation}} are listed several possible practical instantiations, in compliance with NIST SP-800 56Cr2 {{SP800-56C}}.
The shared secret `ss` MAY be used as a Key Encryption Key (KEK) for key encapsulation.

Each `k_i` MUST be constant in length, therefore the secret shares `ss_i` can be used directly only if they are guaranteed to be constant length. For all other cases, it is REQUIRED to hash them first:

~~~
k_i = H(ss_i)
~~~

Any protocols making use of this construction MUST either hash all inputs `ss_i`, or justify that any un-hashed inputs will always be fixed length.

## Protocol binding
The `fixedInfo` string is a fixed-length string containing some context-specific information.
It MUST NOT depend on the secret shares. The intention is to prevent cross-protocol attacks by making this key derivation unique to its protocol context.

The `fixedInfo` string MUST have a definite structure depending on the protocol where all parts are fixed length. This prevents a variable length structure from creating collisions between two different instances.
In cases some variable length input is necessary, such as the representation of a public key or an OID, then hashing or padding can be used.

The parameter fixedInfo MAY contain any of the following information:

* Public information about the communication parties, such as their identifiers.
* The public keys or certificates contributed by each party to the key-agreement transaction.
* Other public and/or private information shared between communication parties before or during the transaction, such as nonces or pre-shared secrets.
* An indication of the protocol or application employing the key-derivation method.
* Protocol-related information, such as a label or session identifier.
* An indication of the key-agreement scheme and/or key-derivation method used.
* An indication of the domain parameters associated with the asymmetric key pairs employed for key establishment.
* An indication of other parameter or primitive choices.
* An indication of how the derived keying material should be parsed, including an indication of which algorithm(s) will use the (parsed) keying material.

This is a non-comprehensive list, further information can be found in paragraph 5.8.2 of NIST SP800-56Ar3 {{SP800-56A}}.

# Practical instantiations {#sec-instantiation}

The KDF MUST be instantiated with one of the following Keccak-based option.
Each instance defines a function to be used as `KDF`, a hash `H` function to optionally derive the `k_i`, and a `counter`.

1. `KDF = SHA3-256` and `H = SHA3-256`, with `hashSize = 256 bit`.
2. `KDF = SHA3-512` and `H = SHA3-512`, with `hashSize = 512 bit`.
3. `KDF = KMAC128` and `H = SHA3-256`, with `hashSize = 128 bit`.
4. `KDF = KMAC256` and `H = SHA3-512`, with `hashSize = 256 bit`.

## Hash-and-counter based construction
Options 1 and 2 instantiate the KDF using SHA3, specified in NIST FIPS 202 {{FIPS202}}.
To generate an `outputBits` long secret share `ss`:

* the `counter` MUST be initialized with the string `0x00000001`.
* The hash is performed over the string defined in {{sec-kem-combiner}}, and repeated `ceil(outputBits/hashSize)` times. For each iteration the `counter` MUST be increased by `0x01`.
* The strings are concatenated ordered by `counter`.
* The leftmost `outputBits` are returned as `ss`.

An implementation MUST NOT overflow and reuse the `counter` and an error MUST be returned when producing more than 2^32 consecutive hashes.

## KMAC based construction
Options 3 and 4 are KMAC-based, as specified in NIST SP 800-185 {{SP800-185}}.
To instantiate the function:

* The context `S` MUST be the utf-8 string "KDF".
* The key `K` MUST be a context-specific string of at least `hashSize` bits, and it MAY be used as an additional option to perform context separation, in scenarios where `fixedInfo` is not sufficient.
* The parameter `counter` MUST be the fixed string `0x00000001`.

To derive a shared secret `ss` of desired length, KMAC is called a single time with the input string `X` defined in {{sec-kem-combiner}} and length `L` being `outputBits`.

# IANA Considerations {#sec-iana}

None.

# Security Considerations

The proposed instantiations in {{sec-instantiation}} are practical multi-PRFs and this specification limits to the use of Keccak-based constructions. The sponge construction was proven to be indifferentiable from a random oracle {{SPONGE}}.
More precisely, for a given capacity `c` the indifferentiability proof shows that assuming there are no weaknesses found in the Keccak permutation, an attacker has to make an expected number of `2^(c/2)` calls to the permutation to tell Keccak from a random oracle.
For a random oracle, a difference in only a single bit gives an unrelated, uniformly random output.
Hence, to be able to distinguish a key `k`, derived from shared keys `k_i` from a random bit string, an adversary has to correctly guess all key shares `k_i` entirely.

<!-- Start of Appendices -->
--- back

# Acknowledgements
{:numbered="false"}

This document incorporates contributions and comments from a large group of experts. The authors would especially like to acknowledge the expertise and tireless dedication of the following people, who attended many long meetings and generated millions of bytes of electronic mail and VOIP traffic over the past years in pursuit of this document:

Douglas Stebila, Nimrod Aviram, Andreas Huelsing, and Stavros Kousidis.

We are grateful to all, including any contributors who may have
been inadvertently omitted from this list.

This document borrows text from similar documents, including those referenced below. Thanks go to the authors of those
   documents.  "Copying always makes things easier and less error prone" - [RFC8411].

<!-- End of Contributors section -->
